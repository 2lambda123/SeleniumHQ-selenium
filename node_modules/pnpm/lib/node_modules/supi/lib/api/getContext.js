"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_loggers_1 = require("@pnpm/core-loggers");
const logger_1 = require("@pnpm/logger");
const modules_yaml_1 = require("@pnpm/modules-yaml");
const utils_1 = require("@pnpm/utils");
const mkdirp = require("mkdirp-promise");
const path = require("path");
const removeAllExceptOuterLinks = require("remove-all-except-outer-links");
const errorTypes_1 = require("../errorTypes");
const readShrinkwrapFiles_1 = require("../readShrinkwrapFiles");
const checkCompatibility_1 = require("./checkCompatibility");
function getContext(opts, installType) {
    return __awaiter(this, void 0, void 0, function* () {
        const storePath = opts.store;
        const modulesPath = path.join(opts.prefix, 'node_modules');
        const modules = yield modules_yaml_1.read(modulesPath);
        if (modules) {
            try {
                if (Boolean(modules.independentLeaves) !== opts.independentLeaves) {
                    if (modules.independentLeaves) {
                        throw new errorTypes_1.PnpmError('ERR_PNPM_INDEPENDENT_LEAVES_WANTED', 'This "node_modules" folder was created using the --independent-leaves option.'
                            + ' You must add that option, or else add the --force option to recreate the "node_modules" folder.');
                    }
                    throw new errorTypes_1.PnpmError('ERR_PNPM_INDEPENDENT_LEAVES_NOT_WANTED', 'This "node_modules" folder was created without the --independent-leaves option.'
                        + ' You must remove that option, or else add the --force option to recreate the "node_modules" folder.');
                }
                if (Boolean(modules.shamefullyFlatten) !== opts.shamefullyFlatten) {
                    if (modules.shamefullyFlatten) {
                        throw new errorTypes_1.PnpmError('ERR_PNPM_SHAMEFULLY_FLATTEN_WANTED', 'This "node_modules" folder was created using the --shamefully-flatten option.'
                            + ' You must add this option, or else add the --force option to recreate the "node_modules" folder.');
                    }
                    throw new errorTypes_1.PnpmError('ERR_PNPM_SHAMEFULLY_FLATTEN_NOT_WANTED', 'This "node_modules" folder was created without the --shamefully-flatten option.'
                        + ' You must remove that option, or else add the --force option to recreate the "node_modules" folder.');
                }
                checkCompatibility_1.default(modules, { storePath, modulesPath });
            }
            catch (err) {
                if (!opts.force)
                    throw err;
                if (installType !== 'general') {
                    throw new Error('Named installation cannot be used to regenerate the node_modules structure. Run pnpm install --force');
                }
                logger_1.default.info({
                    message: `Recreating ${modulesPath}`,
                    prefix: opts.prefix,
                });
                yield removeAllExceptOuterLinks(modulesPath);
                return getContext(opts);
            }
        }
        const files = yield Promise.all([
            utils_1.safeReadPackageFromDir(opts.prefix),
            mkdirp(storePath),
        ]);
        const pkg = files[0] || {};
        const ctx = Object.assign({ hoistedAliases: modules && modules.hoistedAliases || {}, pendingBuilds: modules && modules.pendingBuilds || [], pkg: opts.hooks && opts.hooks.readPackage ? opts.hooks.readPackage(pkg) : pkg, prefix: opts.prefix, skipped: new Set(modules && modules.skipped || []), storePath }, yield readShrinkwrapFiles_1.default(opts));
        core_loggers_1.packageJsonLogger.debug({
            initial: ctx.pkg,
            prefix: opts.prefix,
        });
        return ctx;
    });
}
exports.default = getContext;
//# sourceMappingURL=getContext.js.map